name: 🏷️ Auto Label PR

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
  pull_request_target:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Setup labels first
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const requiredLabels = [
              { name: '✨ Enhancement', color: '0075ca', description: 'New feature or request' },
              { name: '🐛 Bug', color: 'd73a4a', description: 'Something isn\'t working' },
              { name: '⚡ Performance', color: 'f9d71c', description: 'Performance improvements' },
              { name: '♻️ Refactor', color: 'cfd3d7', description: 'Code refactoring' },
              { name: '📚 Documentation', color: '0052cc', description: 'Improvements or additions to documentation' },
              { name: '🧪 Test', color: '0e8a16', description: 'Adding missing tests or correcting existing tests' },
              { name: '🛠️ Build', color: 'fef2c0', description: 'Changes that affect the build system' },
              { name: '🔄 CI/CD', color: '006b75', description: 'Changes to CI configuration files and scripts' },
              { name: '🧹 Maintenance', color: 'fbca04', description: 'Other changes that don\'t modify src or test files' },
              { name: '🎨 Style', color: 'c2e0c6', description: 'Changes that do not affect the meaning of the code' },
              { name: '⏪ Revert', color: 'b60205', description: 'Reverts a previous commit' },
              { name: '🚀 Release', color: 'ff6b35', description: 'Version releases and deployments' },
              { name: '❓ Needs Review', color: 'd876e3', description: 'Requires manual review and labeling' }
            ];

            for (const label of requiredLabels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label.name,
                    color: label.color,
                    description: label.description
                  });
                  console.log(`🆕 Created missing label: ${label.name}`);
                }
              }
            }

      - name: Auto-label PR (Always succeeds, never fails)
        uses: actions/github-script@v7.0.1
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.pull_request.title;
            console.log(`🔍 PR Title: "${title}"`);

            const labelMap = {
              feat: '✨ Enhancement',
              fix: '🐛 Bug',
              perf: '⚡ Performance',
              refactor: '♻️ Refactor',
              docs: '📚 Documentation',
              test: '🧪 Test',
              build: '🛠️ Build',
              ci: '🔄 CI/CD',
              chore: '🧹 Maintenance',
              style: '🎨 Style',
              revert: '⏪ Revert',
              release: '🚀 Release'
            };

            const emojiMap = {
              feat: '✨',
              fix: '🐛',
              perf: '⚡',
              refactor: '♻️',
              docs: '📚',
              test: '🧪',
              build: '🛠️',
              ci: '🔄',
              chore: '🧹',
              style: '🎨',
              revert: '⏪',
              release: '🚀'
            };

            const currentLabels = context.payload.pull_request.labels.map(l => l.name);
            let labelsToAdd = [];
            let detectedType = null;
            let typeSpecificLabel = null;
            let shouldUpdateTitle = false;

            // Try to detect conventional commit format first
            const hasEmoji = /^[\u{1F300}-\u{1F9FF}]|^[\u{2600}-\u{26FF}]|^[\u{2700}-\u{27BF}]/u.test(title);
            const match = title.match(/^(.*?)([a-z]+)(\([^)]+\))?:\s*(.+)$/i) || title.match(/^([a-z]+)(\([^)]+\))?:\s*(.+)$/i);

            if (match) {
              // Check if first group is emoji or type
              const firstGroup = match[1];
              const typeGroup = match[2] || match[1];
              
              if (labelMap[typeGroup.toLowerCase()]) {
                detectedType = typeGroup.toLowerCase();
                typeSpecificLabel = labelMap[detectedType];
                
                if (!hasEmoji && emojiMap[detectedType]) {
                  shouldUpdateTitle = true;
                }
                
                console.log(`🎯 Detected valid type: "${detectedType}" → Label: "${typeSpecificLabel}"`);
              }
            }

            // Determine which label to add based on detection
            if (detectedType && typeSpecificLabel) {
              // Valid type detected - add type-specific label (NOT ❓ Needs Review)
              if (!currentLabels.includes(typeSpecificLabel)) {
                labelsToAdd.push(typeSpecificLabel);
                console.log(`✅ Will add type-specific label: ${typeSpecificLabel}`);
              }
            } else {
              // No valid type detected - add fallback label
              const fallbackLabel = '❓ Needs Review';
              if (!currentLabels.includes(fallbackLabel)) {
                labelsToAdd.push(fallbackLabel);
                console.log(`🔄 No valid type detected, will add fallback label: ${fallbackLabel}`);
              }
            }

            // Apply all labels at once
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: labelsToAdd
                });
                console.log(`✅ Successfully added labels: ${labelsToAdd.join(', ')}`);
              } catch (error) {
                console.log(`⚠️ Could not add labels, continuing anyway: ${error.message}`);
              }
            }

            // Update title with emoji if needed and detected type
            if (shouldUpdateTitle && detectedType && emojiMap[detectedType]) {
              try {
                const newTitle = `${emojiMap[detectedType]} ${title}`;
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  title: newTitle
                });
                console.log(`✏️ Updated title: "${title}" → "${newTitle}"`);
              } catch (error) {
                console.log(`⚠️ Could not update title, continuing anyway: ${error.message}`);
              }
            }

            // Always post a friendly comment (never fails)
            try {
              const commentBody = detectedType && additionalLabel
                ? `🤖 **PR Auto-Labeled Successfully!**\n\n` +
                  `**Detected Type:** \`${detectedType}\` ${emojiMap[detectedType] || ''}\n` +
                  `**Labels Applied:** ${labelsToAdd.join(', ')}\n\n` +
                  `${shouldUpdateTitle ? '✏️ Added emoji to title automatically.\n\n' : ''}` +
                  `Thank you for your contribution! 🚀`
                : `🤖 **PR Labeled for Review**\n\n` +
                  `This PR has been labeled as "❓ Needs Review" for manual review.\n\n` +
                  `**Tip:** Use conventional commit format in your PR title (e.g., \`feat: add feature\`) for automatic labeling!\n\n` +
                  `Thank you for your contribution! 🚀`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });
            } catch (error) {
              console.log(`⚠️ Could not add comment, but continuing: ${error.message}`);
            }

            console.log(`✅ Workflow completed successfully - PR has been labeled!`);

      - name: Ensure PR has at least one label (Final Safety Check)
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const currentLabels = context.payload.pull_request.labels.map(l => l.name);
            console.log(`🔍 Final check - Current labels:`, currentLabels);

            if (currentLabels.length === 0) {
              console.log(`🚨 CRITICAL: PR has no labels! Applying emergency fallback.`);

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['❓ Needs Review']
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `🚨 **Emergency Labeling Applied**\n\n` +
                      `This PR was automatically labeled as "❓ Needs Review" because no other labels could be applied.\n\n` +
                      `**Please:**\n` +
                      `1. Update the PR title to follow conventional commit format\n` +
                      `2. Or manually apply appropriate labels\n\n` +
                      `This ensures proper organization and searchability of PRs.`
              });

              console.log(`✅ Emergency fallback label applied successfully`);
            } else {
              console.log(`✅ PR has ${currentLabels.length} label(s) - all good!`);
            }
