name: üè∑Ô∏è Auto Label PR

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]
  pull_request_target:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false

    steps:
      - name: Setup labels first
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const requiredLabels = [
              { name: '‚ú® Enhancement', color: '0075ca', description: 'New feature or request' },
              { name: 'üêõ Bug', color: 'd73a4a', description: 'Something isn\'t working' },
              { name: '‚ö° Performance', color: 'f9d71c', description: 'Performance improvements' },
              { name: '‚ôªÔ∏è Refactor', color: 'cfd3d7', description: 'Code refactoring' },
              { name: 'üìö Documentation', color: '0052cc', description: 'Improvements or additions to documentation' },
              { name: 'üß™ Test', color: '0e8a16', description: 'Adding missing tests or correcting existing tests' },
              { name: 'üõ†Ô∏è Build', color: 'fef2c0', description: 'Changes that affect the build system' },
              { name: 'üîÑ CI/CD', color: '006b75', description: 'Changes to CI configuration files and scripts' },
              { name: 'üßπ Maintenance', color: 'fbca04', description: 'Other changes that don\'t modify src or test files' },
              { name: 'üé® Style', color: 'c2e0c6', description: 'Changes that do not affect the meaning of the code' },
              { name: '‚è™ Revert', color: 'b60205', description: 'Reverts a previous commit' },
              { name: 'üöÄ Release', color: 'ff6b35', description: 'Version releases and deployments' },
              { name: '‚ùì Needs Review', color: 'd876e3', description: 'Requires manual review and labeling' }
            ];

            for (const label of requiredLabels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label.name,
                    color: label.color,
                    description: label.description
                  });
                  console.log(`üÜï Created missing label: ${label.name}`);
                }
              }
            }

      - name: Auto-label PR (Always succeeds, never fails)
        uses: actions/github-script@v7.0.1
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = context.payload.pull_request.title;
            console.log(`üîç PR Title: "${title}"`);

            const labelMap = {
              feat: '‚ú® Enhancement',
              fix: 'üêõ Bug',
              perf: '‚ö° Performance',
              refactor: '‚ôªÔ∏è Refactor',
              docs: 'üìö Documentation',
              test: 'üß™ Test',
              build: 'üõ†Ô∏è Build',
              ci: 'üîÑ CI/CD',
              chore: 'üßπ Maintenance',
              style: 'üé® Style',
              revert: '‚è™ Revert',
              release: 'üöÄ Release'
            };

            const emojiMap = {
              feat: '‚ú®',
              fix: 'üêõ',
              perf: '‚ö°',
              refactor: '‚ôªÔ∏è',
              docs: 'üìö',
              test: 'üß™',
              build: 'üõ†Ô∏è',
              ci: 'üîÑ',
              chore: 'üßπ',
              style: 'üé®',
              revert: '‚è™',
              release: 'üöÄ'
            };

            const currentLabels = context.payload.pull_request.labels.map(l => l.name);
            let labelsToAdd = [];
            let detectedType = null;
            let typeSpecificLabel = null;
            let shouldUpdateTitle = false;

            // Try to detect conventional commit format first
            const hasEmoji = /^[\u{1F300}-\u{1F9FF}]|^[\u{2600}-\u{26FF}]|^[\u{2700}-\u{27BF}]/u.test(title);
            const match = title.match(/^(.*?)([a-z]+)(\([^)]+\))?:\s*(.+)$/i) || title.match(/^([a-z]+)(\([^)]+\))?:\s*(.+)$/i);

            if (match) {
              // Check if first group is emoji or type
              const firstGroup = match[1];
              const typeGroup = match[2] || match[1];
              
              if (labelMap[typeGroup.toLowerCase()]) {
                detectedType = typeGroup.toLowerCase();
                typeSpecificLabel = labelMap[detectedType];
                
                if (!hasEmoji && emojiMap[detectedType]) {
                  shouldUpdateTitle = true;
                }
                
                console.log(`üéØ Detected valid type: "${detectedType}" ‚Üí Label: "${typeSpecificLabel}"`);
              }
            }

            // Determine which label to add based on detection
            if (detectedType && typeSpecificLabel) {
              // Valid type detected - add type-specific label (NOT ‚ùì Needs Review)
              if (!currentLabels.includes(typeSpecificLabel)) {
                labelsToAdd.push(typeSpecificLabel);
                console.log(`‚úÖ Will add type-specific label: ${typeSpecificLabel}`);
              }
            } else {
              // No valid type detected - add fallback label
              const fallbackLabel = '‚ùì Needs Review';
              if (!currentLabels.includes(fallbackLabel)) {
                labelsToAdd.push(fallbackLabel);
                console.log(`üîÑ No valid type detected, will add fallback label: ${fallbackLabel}`);
              }
            }

            // Apply all labels at once
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  labels: labelsToAdd
                });
                console.log(`‚úÖ Successfully added labels: ${labelsToAdd.join(', ')}`);
              } catch (error) {
                console.log(`‚ö†Ô∏è Could not add labels, continuing anyway: ${error.message}`);
              }
            }

            // Update title with emoji if needed and detected type
            if (shouldUpdateTitle && detectedType && emojiMap[detectedType]) {
              try {
                const newTitle = `${emojiMap[detectedType]} ${title}`;
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  title: newTitle
                });
                console.log(`‚úèÔ∏è Updated title: "${title}" ‚Üí "${newTitle}"`);
              } catch (error) {
                console.log(`‚ö†Ô∏è Could not update title, continuing anyway: ${error.message}`);
              }
            }

            // Always post a friendly comment (never fails)
            try {
              const commentBody = detectedType && additionalLabel
                ? `ü§ñ **PR Auto-Labeled Successfully!**\n\n` +
                  `**Detected Type:** \`${detectedType}\` ${emojiMap[detectedType] || ''}\n` +
                  `**Labels Applied:** ${labelsToAdd.join(', ')}\n\n` +
                  `${shouldUpdateTitle ? '‚úèÔ∏è Added emoji to title automatically.\n\n' : ''}` +
                  `Thank you for your contribution! üöÄ`
                : `ü§ñ **PR Labeled for Review**\n\n` +
                  `This PR has been labeled as "‚ùì Needs Review" for manual review.\n\n` +
                  `**Tip:** Use conventional commit format in your PR title (e.g., \`feat: add feature\`) for automatic labeling!\n\n` +
                  `Thank you for your contribution! üöÄ`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: commentBody
              });
            } catch (error) {
              console.log(`‚ö†Ô∏è Could not add comment, but continuing: ${error.message}`);
            }

            console.log(`‚úÖ Workflow completed successfully - PR has been labeled!`);

      - name: Ensure PR has at least one label (Final Safety Check)
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const currentLabels = context.payload.pull_request.labels.map(l => l.name);
            console.log(`üîç Final check - Current labels:`, currentLabels);

            if (currentLabels.length === 0) {
              console.log(`üö® CRITICAL: PR has no labels! Applying emergency fallback.`);

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['‚ùì Needs Review']
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `üö® **Emergency Labeling Applied**\n\n` +
                      `This PR was automatically labeled as "‚ùì Needs Review" because no other labels could be applied.\n\n` +
                      `**Please:**\n` +
                      `1. Update the PR title to follow conventional commit format\n` +
                      `2. Or manually apply appropriate labels\n\n` +
                      `This ensures proper organization and searchability of PRs.`
              });

              console.log(`‚úÖ Emergency fallback label applied successfully`);
            } else {
              console.log(`‚úÖ PR has ${currentLabels.length} label(s) - all good!`);
            }
